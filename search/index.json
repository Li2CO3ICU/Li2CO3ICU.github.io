[{"content":"✨$Markdown$ 学习记录 1. 标题 一级标题 #一级标题 二级标题 ##二级标题 三级标题 ###三级标题 四级标题 ####四级标题 五级标题 #####五级标题 六级标题 ######六级标题 2. 特殊格式 斜体 *斜体* 斜体 _斜体_ 加粗 **加粗** 加粗斜体 ***加粗斜体*** 删除线 ~~删除线~~ 3. 列表 无序列表1 - 无序列表1 无序列表2 - 无序列表2 子项 - 子项 有序列表1 1. 有序列表1 有序列表2 2. 有序列表2 子项 1. 子项 4. 链接\u0026amp;图片 链接文字\r[链接文字](blog.li2co3.icu) ![图片说明](https://blog.li2co3.icu/%E5%85%B3%E4%BA%8Eabout/Skill_Icons/c.png) 这里应该有一个C的图片\n\u0026lt;img src=\u0026quot;https://blog.li2co3.icu/%E5%85%B3%E4%BA%8Eabout/Skill_Icons/py.png\u0026quot; width=\u0026quot;200\u0026quot;\u0026gt;\n这里应该有一个Python的图片\n5. 引用 引用文本 \u0026gt;引用文本\n嵌套引用 \u0026gt;\u0026gt;嵌套引用\n引用可以无限嵌套\n6. Code 行内代码示例 行内代码 `行内代码` 多行代码 1 2 3 4 5 6 print(\u0026#34;Hello markdown!\u0026#34;) 以下是源码 \\``` print(\u0026#34;Hello markdown!\u0026#34;) 多行代码带语言高亮版本 1 2 3 4 5 6 print(\u0026#34;Hello markdown!\u0026#34;) 以下是源码 \\```python print(\u0026#34;Hello markdown!\u0026#34;) 1 2 3 fn main() { println!(\u0026#34;Hello markdown!\u0026#34;) } 7. 分割线 --- 8. 列表 username password keyword Li2CO3 password123 XiaoShi 1 2 3 |username|password|keyword| |:------:|:------:|:-----:| |Li2CO3|password123|XiaoShi| 9. 脚注 hello markdown1 1 2 hello markdown[^markdown] [^markdown]:一种排版格式 10. 数学公式 $e^{i\\pi}+1=0$ $e^{i\\pi}+1=0$ $Li_2CO_3$ $Li_2CO_3$ 一种排版格式\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-09-22T12:21:22+08:00","image":"https://li2co3icu.github.io/p/markdown-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/top_hu_8d2ae58b1394b25a.jpg","permalink":"https://li2co3icu.github.io/p/markdown-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","title":"Markdown 学习记录"},{"content":"1. RUST 的数据类型 整数类型 类型 | 无符号整数 范围 u8 0~28-1 u16 0~216-1 u32 0~232-1 u64 0~264-1 u128 0~2128-1 usize 0~232-1 or 0-264-1 usize取决于系统位数,32为32，64为64. 类型 | 有符号整数 范围 i8 -27~27-1 i16 -215~215-1 i32 -231~231-1 i64 -263~263-1 i128 -2127~2127-1 isize -231~231-1 or -263~263-1 isize同上取决于系统位数,32为31，64为63. 浮点类型 类型 精度 范围 f32 IEEE 单精度(至少6位小数) 约-3.4×1038~3.4×1038 f64 IEEE 双精度(至少15位小数) 约-1.8×10308~1.8×10308 布尔类型 即 True \u0026amp; False 字符类型 Rust的字符类型以32位值的形式表示单个Unicode字符 这使得它可以支持i18n甚至包括emoji 数组 最简单的形式，将数据直接括起来：[1,1,2,3,5,8,13] *不要把数组局限于数；如[\u0026quot;hello\u0026quot;, \u0026quot;rust\u0026quot;, \u0026quot;love\u0026quot;, \u0026quot;you\u0026quot;]\n也是一个合法的数组 可以通过[V; N]来生成一个相同元素的数组； 其中，V为每个元素的值[Value], N为数据个数[Number]. 元组 元组不同于数组，元组中的元素可以是任何类型\n例如(\u0026quot;rust\u0026quot;, 520)是一个元组，它的类型是(\u0026amp;str, i32) 访问元组中元素的方法tup.0, tup.1, tup.2\nindex从0开始 *零元组：() 指针类型 引用 \u0026amp;xx类型的值就是对一个xx值的引用\n\u0026amp;T : 不可变引用；\n\u0026amp;mut T : 可变引用.\nBox 1 2 let tup_1 = (12, \u0026#34;eggs\u0026#34;); let box_1 = Box:new(tup_1); //在堆中分配一个元组 box分配的元组在堆内存中，即涉及到所有权 原始指针 *mut T *const T 星号[*]还可以表示解引用\n向量 向量Vec\u0026lt;T\u0026gt;分配在堆内存上[可变]\n1 let mut vec_1 = vec![2, 3, 5, 7]; 以上使用了vec!宏创建向量 1 2 vec_1.push(11); vec_1.push(13); 以上使用push()向vec_1向量中添加元素 切片 以下先创建数组与向量\n1 2 let vec_1: Vec\u0026lt;f64\u0026gt; = vec![0.0, 0.707, 1.0, 0.707]; let arr_1: [f64; 4] = [0.0, -0.707, -1.0, -0.707]; 首先来介绍普通引用 1 2 let sv: \u0026amp;[f64] = \u0026amp;vec_1; let sa: \u0026amp;[f64] = \u0026amp;arr_1; 以上创建了不可变引用\nsv和sa的指针指向源数据而不是创建了新的数组和向量\n此时sv和sa输出结果和vec_1和arr_1相同\n若想获得特定的元素或者元素片段，则需要进行切片\n切片 可以使用如下语句来将数组或者向量切片\n1 2 3 print(\u0026amp;vec_1[0..2]); //打印vec_1的前两个元素 print(\u0026amp;arr_1[2..]); //从a[2]开始打印arr_1的元素 print(\u0026amp;sv[1..3]); //这是有趣的一部分，因为它对一个切片进行了切片！ 未完待续\n","date":"2025-09-22T12:21:22+08:00","image":"https://li2co3icu.github.io/p/rust-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/top_hu_87610e2e4efa6461.jpg","permalink":"https://li2co3icu.github.io/p/rust-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","title":"RUST 学习记录"}]